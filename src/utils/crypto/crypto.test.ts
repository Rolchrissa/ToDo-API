// Generated by CodiumAI

import { hashPassword, validatePassword } from "./bcrypt";
import bcrypt from "bcrypt";

describe("validatePassword_function", () => {
  // Tests that a valid password matches the correct hash. tags: [happy path]
  test("test_valid_password_matching_hash", async () => {
    const password = "password123";
    const hash = await bcrypt.hash(password, 10);
    const isValid = await validatePassword(password, hash);
    expect(isValid).toBe(true);
  });

  // Tests that a valid password does not match an incorrect hash. tags: [happy path]
  test("test_valid_password_non_matching_hash", async () => {
    const password = "password123";
    const hash = await bcrypt.hash(password, 10);
    const isValid = await validatePassword("wrongpassword", hash);
    expect(isValid).toBe(false);
  });

  // Tests that an invalid password matches the correct hash. tags: [edge case]
  test("test_invalid_password_matching_hash", async () => {
    const password = "password123";
    const hash = await bcrypt.hash(password, 10);
    const isValid = await validatePassword("wrongpassword", hash);
    expect(isValid).toBe(false);
  });

  // Tests that an invalid password does not match an incorrect hash. tags: [edge case]
  test("test_invalid_password_non_matching_hash", async () => {
    const password = "password123";
    const hash = await bcrypt.hash(password, 10);
    const isValid = await validatePassword("wrongpassword", "wronghash");
    expect(isValid).toBe(false);
  });

  // Tests that the function returns a promise. tags: [general behavior]
  test("test_returns_promise", () => {
    const password = "password123";
    const hash = bcrypt.hashSync(password, 10);
    const promise = validatePassword(password, hash);
    expect(promise).toBeInstanceOf(Promise);
  });

  // Tests that the promise resolves to a boolean value. tags: [general behavior]
});

describe("hashPassword_function", () => {
  // Tests that a valid password string is provided as input and a hashed password is returned as a string. tags: [happy path]
  test("test_valid_password: should return a hashed password string when a valid password string is provided", async () => {
    const password = "password123";
    const hashedPassword = await hashPassword(password);
    expect(typeof hashedPassword).toBe("string");
  });

  // Tests that an empty string is provided as input and an error is thrown. tags: [edge case]
  test("test_empty_string: should throw an error when an empty string is provided as input", async () => {
    const password = "";
    await expect(hashPassword(password)).rejects.toThrow();
  });

  // Tests that a null value is provided as input and an error is thrown. tags: [edge case]
  test("test_null_value: should throw an error when a null value is provided as input", async () => {
    const password = null;
    await expect(hashPassword(password)).rejects.toThrow();
  });

  // Tests that a password string exceeds the maximum length allowed by bcrypt and an error is thrown. tags: [edge case]
  test("test_max_length_exceeded: should throw an error when a password string exceeds the maximum length allowed by bcrypt", async () => {
    const password = "a".repeat(73);
    await expect(hashPassword(password)).rejects.toThrow();
  });

  // Tests that salt generation fails and an error is thrown. tags: [edge case]
  test("test_salt_generation_failure: should throw an error when salt generation fails", async () => {
    jest
      .spyOn(bcrypt, "genSalt")
      .mockRejectedValue(new Error("Salt generation failed"));
    const password = "password123";
    await expect(hashPassword(password)).rejects.toThrow();
  });

  // Tests that hashing fails and an error is thrown. tags: [edge case]
  test("test_hashing_failure: should throw an error when hashing fails", async () => {
    jest.spyOn(bcrypt, "hash").mockRejectedValue(new Error("Hashing failed"));
    const password = "password123";
    await expect(hashPassword(password)).rejects.toThrow();
  });
});
